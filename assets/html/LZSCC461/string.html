<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>4 String processing | Lancaster University Leipzig LZSCC.461 R Programming</title>
  <meta name="description" content="4 String processing | Lancaster University Leipzig LZSCC.461 R Programming" />
  <meta name="generator" content="bookdown 0.41 and GitBook 2.6.7" />

  <meta property="og:title" content="4 String processing | Lancaster University Leipzig LZSCC.461 R Programming" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="4 String processing | Lancaster University Leipzig LZSCC.461 R Programming" />
  
  
  

<meta name="author" content="Lecturer: Robert Lösch" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="loops-sim.html"/>
<link rel="next" href="web-app.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
<link href="libs/htmltools-fill-0.5.8.1/fill.css" rel="stylesheet" />
<script src="libs/htmlwidgets-1.6.4/htmlwidgets.js"></script>
<script src="libs/plotly-binding-4.10.4/plotly.js"></script>
<script src="libs/typedarray-0.1/typedarray.min.js"></script>
<link href="libs/crosstalk-1.2.1/css/crosstalk.min.css" rel="stylesheet" />
<script src="libs/crosstalk-1.2.1/js/crosstalk.min.js"></script>
<link href="libs/plotly-htmlwidgets-css-2.11.1/plotly-htmlwidgets.css" rel="stylesheet" />
<script src="libs/plotly-main-2.11.1/plotly-latest.min.js"></script>
<script src="libs/detect-resize-0.5.3/jquery.resize.js"></script>
<link href="libs/jquery-ui-1.11.4/jquery-ui.min.css" rel="stylesheet" />
<script src="libs/jquery-ui-1.11.4/jquery-ui.min.js"></script>
<script src="libs/d3-3.5.2/d3.min.js"></script>
<script src="libs/vega-1.4.3/vega.min.js"></script>
<script src="libs/lodash-4.17.21/lodash.min.js"></script>
<script>var lodash = _.noConflict();</script>
<link href="libs/ggvis-0.4.9/css/ggvis.css" rel="stylesheet" />
<script src="libs/ggvis-0.4.9/js/ggvis.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="" data-path="introduction-to-r.html"><a href="introduction-to-r.html"><i class="fa fa-check"></i><strong>0</strong> Introduction to R</a>
<ul>
<li class="chapter" data-level="0.1" data-path="introduction-to-r.html"><a href="introduction-to-r.html#background"><i class="fa fa-check"></i><b>0.1</b> Background</a></li>
<li class="chapter" data-level="0.2" data-path="introduction-to-r.html"><a href="introduction-to-r.html#saving-your-work"><i class="fa fa-check"></i><b>0.2</b> Saving your work</a></li>
<li class="chapter" data-level="0.3" data-path="introduction-to-r.html"><a href="introduction-to-r.html#getting-started"><i class="fa fa-check"></i><b>0.3</b> Getting started</a></li>
<li class="chapter" data-level="0.4" data-path="introduction-to-r.html"><a href="introduction-to-r.html#s:0help"><i class="fa fa-check"></i><b>0.4</b> Getting Help</a></li>
<li class="chapter" data-level="0.5" data-path="introduction-to-r.html"><a href="introduction-to-r.html#r-scripts"><i class="fa fa-check"></i><b>0.5</b> R scripts</a></li>
<li class="chapter" data-level="0.6" data-path="introduction-to-r.html"><a href="introduction-to-r.html#r-markdown"><i class="fa fa-check"></i><b>0.6</b> R Markdown</a></li>
<li class="chapter" data-level="0.7" data-path="introduction-to-r.html"><a href="introduction-to-r.html#functions"><i class="fa fa-check"></i><b>0.7</b> Functions</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="read-plot.html"><a href="read-plot.html"><i class="fa fa-check"></i><b>1</b> Data manipulation and plotting in R</a>
<ul>
<li class="chapter" data-level="1.1" data-path="read-plot.html"><a href="read-plot.html#before-getting-started"><i class="fa fa-check"></i><b>1.1</b> Before getting started</a></li>
<li class="chapter" data-level="1.2" data-path="read-plot.html"><a href="read-plot.html#working-with-data-in-modern-r"><i class="fa fa-check"></i><b>1.2</b> Working with data in modern R</a></li>
<li class="chapter" data-level="1.3" data-path="read-plot.html"><a href="read-plot.html#data-types"><i class="fa fa-check"></i><b>1.3</b> Data Types</a></li>
<li class="chapter" data-level="1.4" data-path="read-plot.html"><a href="read-plot.html#logical-comparisons-and-boolean-operations"><i class="fa fa-check"></i><b>1.4</b> Logical comparisons and Boolean operations</a></li>
<li class="chapter" data-level="1.5" data-path="read-plot.html"><a href="read-plot.html#plots"><i class="fa fa-check"></i><b>1.5</b> Plots</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="time.html"><a href="time.html"><i class="fa fa-check"></i><b>2</b> Time manipulation, aggregation and summarisation</a>
<ul>
<li class="chapter" data-level="2.1" data-path="time.html"><a href="time.html#from-last-week"><i class="fa fa-check"></i><b>2.1</b> From last week</a></li>
<li class="chapter" data-level="2.2" data-path="time.html"><a href="time.html#dates-and-timestamps-in-r"><i class="fa fa-check"></i><b>2.2</b> Dates and timestamps in R</a></li>
<li class="chapter" data-level="2.3" data-path="time.html"><a href="time.html#summarising-data-over-time"><i class="fa fa-check"></i><b>2.3</b> Summarising data over time</a></li>
<li class="chapter" data-level="2.4" data-path="time.html"><a href="time.html#a-timestamp-split-over-several-columns"><i class="fa fa-check"></i><b>2.4</b> A timestamp split over several columns</a></li>
<li class="chapter" data-level="2.5" data-path="time.html"><a href="time.html#time-zones"><i class="fa fa-check"></i><b>2.5</b> Time zones</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="loops-sim.html"><a href="loops-sim.html"><i class="fa fa-check"></i><b>3</b> Loops, Conditional Statements, and Simulation</a>
<ul>
<li class="chapter" data-level="3.1" data-path="loops-sim.html"><a href="loops-sim.html#before-you-start"><i class="fa fa-check"></i><b>3.1</b> Before you start</a></li>
<li class="chapter" data-level="3.2" data-path="loops-sim.html"><a href="loops-sim.html#loops"><i class="fa fa-check"></i><b>3.2</b> Loops</a></li>
<li class="chapter" data-level="3.3" data-path="loops-sim.html"><a href="loops-sim.html#conditional-statements"><i class="fa fa-check"></i><b>3.3</b> Conditional statements</a></li>
<li class="chapter" data-level="3.4" data-path="loops-sim.html"><a href="loops-sim.html#probability-and-simulation"><i class="fa fa-check"></i><b>3.4</b> Probability and Simulation</a></li>
<li class="chapter" data-level="3.5" data-path="loops-sim.html"><a href="loops-sim.html#combining-loops-and-simulation"><i class="fa fa-check"></i><b>3.5</b> Combining Loops and Simulation</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="string.html"><a href="string.html"><i class="fa fa-check"></i><b>4</b> String processing</a>
<ul>
<li class="chapter" data-level="4.1" data-path="string.html"><a href="string.html#preamble"><i class="fa fa-check"></i><b>4.1</b> Preamble</a></li>
<li class="chapter" data-level="4.2" data-path="string.html"><a href="string.html#introducing-regular-expressions"><i class="fa fa-check"></i><b>4.2</b> Introducing regular expressions</a></li>
<li class="chapter" data-level="4.3" data-path="string.html"><a href="string.html#working-with-strings-and-regular-expressions"><i class="fa fa-check"></i><b>4.3</b> Working with strings and regular expressions</a></li>
<li class="chapter" data-level="4.4" data-path="string.html"><a href="string.html#string-exercises"><i class="fa fa-check"></i><b>4.4</b> String Exercises</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="web-app.html"><a href="web-app.html"><i class="fa fa-check"></i><b>5</b> Web scraping, interactive graphics, Shiny Apps, package building, and more</a>
<ul>
<li class="chapter" data-level="5.1" data-path="web-app.html"><a href="web-app.html#packages"><i class="fa fa-check"></i><b>5.1</b> Packages</a></li>
<li class="chapter" data-level="5.2" data-path="web-app.html"><a href="web-app.html#collecting-data"><i class="fa fa-check"></i><b>5.2</b> Collecting data</a></li>
<li class="chapter" data-level="5.3" data-path="web-app.html"><a href="web-app.html#alternative-graphics"><i class="fa fa-check"></i><b>5.3</b> Alternative graphics</a></li>
<li class="chapter" data-level="5.4" data-path="web-app.html"><a href="web-app.html#shiny-web-applications"><i class="fa fa-check"></i><b>5.4</b> Shiny Web Applications</a></li>
<li class="chapter" data-level="5.5" data-path="web-app.html"><a href="web-app.html#r-markdown-html-notebooks-and-ipythonjupyter-notebooks"><i class="fa fa-check"></i><b>5.5</b> R Markdown HTML notebooks and IPython/Jupyter notebooks</a></li>
<li class="chapter" data-level="5.6" data-path="web-app.html"><a href="web-app.html#exercise-housing-in-nairobi"><i class="fa fa-check"></i><b>5.6</b> Exercise: Housing in Nairobi</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="further-reading.html"><a href="further-reading.html"><i class="fa fa-check"></i>Further reading</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Lancaster University Leipzig LZSCC.461 R Programming</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="string" class="section level1 hasAnchor" number="4">
<h1><span class="header-section-number">4</span> String processing<a href="string.html#string" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="preamble" class="section level2 hasAnchor" number="4.1">
<h2><span class="header-section-number">4.1</span> Preamble<a href="string.html#preamble" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<ul>
<li>Install the <code>stringr</code> package if it is not already available on your machine.</li>
<li>Load your favourite packages at the start of a new script:</li>
</ul>
<div class="sourceCode" id="cb495"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb495-1"><a href="string.html#cb495-1" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb495-2"><a href="string.html#cb495-2" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb495-3"><a href="string.html#cb495-3" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb495-4"><a href="string.html#cb495-4" tabindex="-1"></a></span>
<span id="cb495-5"><a href="string.html#cb495-5" tabindex="-1"></a><span class="co"># Or more simply</span></span>
<span id="cb495-6"><a href="string.html#cb495-6" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code></pre></div>
</div>
<div id="introducing-regular-expressions" class="section level2 hasAnchor" number="4.2">
<h2><span class="header-section-number">4.2</span> Introducing regular expressions<a href="string.html#introducing-regular-expressions" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Regular expressions are special phrases that we construct to help find
and match patterns in a large body of text or sets of strings.
They exist in almost all programming languages and are a useful tool when
interacting with computers in all sorts of ways:</p>
<ul>
<li>Finding files on a system with a particular pattern in their filename.</li>
<li>Parsing a log file which contains thousands of lines, hunting down the reason for a server repeatedly crashing.</li>
<li>Generating features and statistics from bodies of text e.g. how many times does the word “potato” appear in each of the works of Shakespeare. Another example; pulling out hashtags from tweets.</li>
<li>Parse a web-page, storing all references to other websites.</li>
<li>Automating the finding and replacing text.</li>
</ul>
<p>You will be starting with an expression as simple as this:</p>
<pre><code>\d</code></pre>
<p>which is <em>one</em> way of saying “any character that matches a <strong>d</strong>igit from 0 to 9”. And moving to something a bit more complicated, such as:</p>
<pre><code>(\(\d{5}\)|\d{5})[ -.]?\d{5,6}</code></pre>
<p>which matches a 10 or 11 digit, UK telephone number, with or without parentheses around the area code, and with or without a hyphen, dot (period) or space to separate the numbers.</p>
<p>This chapter will give you an idea of the simpler ways to match patterns in text
using:</p>
<ul>
<li>Literal text</li>
<li>Digits</li>
<li>Letters</li>
<li>Characters of any kind</li>
</ul>
<p>We will start by using the website RegExr to help you build and understand
regular expressions: <a href="http://www.regexr.com/" class="uri">http://www.regexr.com/</a></p>
<p>Open <code>fake_phone_numbers.txt</code>, a file in the folder on
Moodle. Copy and paste its contents into the “Text” area on RegExr.</p>
<div id="matching-literal-text" class="section level3 hasAnchor" number="4.2.1">
<h3><span class="header-section-number">4.2.1</span> Matching literal text<a href="string.html#matching-literal-text" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The most obvious feature of regular expressions is matching strings
with one or more literal characters, called <em>literal text</em> or
just <em>literals</em>.
The way to match literal text is with normal, literal characters.
This is similar to the way you might try to find a phrase in a word document
or when submitting a keyword to a search engine. When you search for a string of text,
character for character, you are searching with literal text.</p>
<p>If you want to match the Lancaster area code, 01524, for example, which is a
number sequence (string of digits), just type <code>01524</code> in the “Expression” box at the top of RegExr, and then all the matching area codes will be highlighted in the text.
If nothing is highlighted, check what you typed.</p>
</div>
<div id="matching-digits" class="section level3 hasAnchor" number="4.2.2">
<h3><span class="header-section-number">4.2.2</span> Matching digits<a href="string.html#matching-digits" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the Expression box, replace the literal text, 01524, with:</p>
<pre><code>\d</code></pre>
<p>This matches all the Arabic digits in the text.
Now in place of <code>\d</code> use a character class that matches
the same thing. Enter the following range of digits as the Expression:</p>
<pre><code>[0-9]</code></pre>
<p>Though the syntax is different, using <code>\d</code> does the same
thing as <code>[0-9]</code>.
When we use square-brackets like this we are specifying a <em>character class</em>,
you will learn more about character classes later.
The character class <code>[0-9]</code> is a range, meaning that it will match the
range of digits 0 through 9. You could also match digits 0 through 9 by listing all the digits:</p>
<pre><code>[0123456789]</code></pre>
<p>If you want to match only the binary digits 0 and 1, you would use this
character class:</p>
<pre><code>[01]</code></pre>
<p>Try <code>[23]</code> in RegExr and look at the result. With a character class,
you can pick the exact digits you want to match. The character shorthand
for “all digits” (<code>\d</code>) is shorter and simpler, but it does not have the power or flexibility of the character class. Use character classes when you need to get very specific about what digits you need to match; otherwise, use <code>\d</code> because it is a simpler, more convenient syntax.</p>
</div>
<div id="matching-non-digits" class="section level3 hasAnchor" number="4.2.3">
<h3><span class="header-section-number">4.2.3</span> Matching non-digits<a href="string.html#matching-non-digits" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>if you want to match characters that are not digits, use the shorthand:</p>
<pre><code>\D</code></pre>
<p>Try this in RegExr now. An uppercase <code>D</code>, rather than a lowercase, matches
non-digit characters. This shorthand is the same as the following
character class</p>
<pre><code>[^0-9]</code></pre>
<p>This is a negated class (a negated class says in essence, “do not match these”
or “match all but these”), which is the same as:</p>
<pre><code>[^\d]</code></pre>
</div>
<div id="matching-words-and-non-words" class="section level3 hasAnchor" number="4.2.4">
<h3><span class="header-section-number">4.2.4</span> Matching words and non-words<a href="string.html#matching-words-and-non-words" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The fake phone numbers data obviously do not contain any word text. Go to
<a href="http://www.authorama.com/" class="uri">http://www.authorama.com/</a>, which contains books that are in the public domain. Examples include, Alice in Wonderland, Flatland, and Frankenstein. Pick one and copy the first page of text into the Text area on RegExr, replacing the fake phone numbers. Now, in the Expression box,
swap <code>\D</code> with:</p>
<pre><code>\w</code></pre>
<p>This shorthand will match all word characters. The difference between
<code>\D</code> and <code>\w</code> is that <code>\D</code> matches whitespace, punctuation, quotation
marks, hyphens, forward slashes, square brackets, and other similar characters,
while <code>\w</code> does not, it only matches letters and numbers.
In English, <code>\w</code> matches essentially the same thing as
the character class:</p>
<pre><code>[a-zA-Z0-9]</code></pre>
<p>To match a non-word character:</p>
<pre><code>\W</code></pre>
<p>This shorthand matches whitespace, punctuation, and other kinds of characters
that are not used in words. It is equivalent to the following character class:</p>
<pre><code>[^a-zA-Z0-9]</code></pre>
<p>Character classes allow you more control over what you match, but
a lot of the time you do not need to type out all those characters.
But sometimes you must explicitly state a character class in order to
get precisely what you want. Try both:</p>
<pre><code>[^\w]
[^\W]</code></pre>
<p>Can you see the differences in what text they match?
Table <a href="string.html#tab:shorthand">4.1</a> shows a summary of shorthand character classes.</p>
<table>
<caption><span id="tab:shorthand">Table 4.1: </span> Shorthand character classes</caption>
<thead>
<tr class="header">
<th>Shorthand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\d</code></td>
<td>digit</td>
</tr>
<tr class="even">
<td><code>\D</code></td>
<td>non-digit</td>
</tr>
<tr class="odd">
<td><code>\w</code></td>
<td>word</td>
</tr>
<tr class="even">
<td><code>\W</code></td>
<td>non-word</td>
</tr>
<tr class="odd">
<td><code>\b</code></td>
<td>word boundary</td>
</tr>
<tr class="even">
<td><code>\B</code></td>
<td>non-word boundary</td>
</tr>
<tr class="odd">
<td><code>\s</code></td>
<td>space character</td>
</tr>
<tr class="even">
<td><code>\S</code></td>
<td>non-space character</td>
</tr>
<tr class="odd">
<td><code>\t</code></td>
<td>tab character</td>
</tr>
<tr class="even">
<td><code>\T</code></td>
<td>non-tab character</td>
</tr>
</tbody>
</table>
</div>
<div id="matching-a-literal-word" class="section level3 hasAnchor" number="4.2.5">
<h3><span class="header-section-number">4.2.5</span> Matching a literal word<a href="string.html#matching-a-literal-word" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Going back to matching literal text, replace the expression with <code>at</code>,
all instances of “at” in your text should now be highlighted. This includes instances
where “at” is the actual word, and instances where “at” has occurred within
a word, for example, “c<strong>at</strong> s<strong>at</strong> on the m<strong>at</strong>”.
To match only instances of the actual word “at” change the expression so it
becomes:</p>
<pre><code>\bat\b</code></pre>
<p>Here <code>\b</code> stands for <em>word-boundary</em>, and it matches the start or the end of a word.
The first <code>\b</code> requires the <code>a</code> to occur at the very start of the word, or after a non-word character. The second <code>\b</code> requires the <code>t</code> to occur at the very end of the word, or before a non-word character.</p>
</div>
<div id="matching-whitespace" class="section level3 hasAnchor" number="4.2.6">
<h3><span class="header-section-number">4.2.6</span> Matching whitespace<a href="string.html#matching-whitespace" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To match whitespace, try the following in RegExr and see what is highlighted:</p>
<pre><code>\s</code></pre>
<p>The following character class matches the same characters:</p>
<pre><code>[ \t\n\r]</code></pre>
<p>which are the characters for spaces, tabs (<code>\t</code>),
new lines (<code>\n</code>), and carriage returns (<code>\r</code>).</p>
<p>To match a non-whitespace use:</p>
<pre><code>\S</code></pre>
<p>which is equivalent to:</p>
<pre><code>[^ \t\n\r]</code></pre>
</div>
<div id="matching-any-character" class="section level3 hasAnchor" number="4.2.7">
<h3><span class="header-section-number">4.2.7</span> Matching any character<a href="string.html#matching-any-character" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To match any character with regular expressions use the dot,
also known as a period or a full stop. The dot matches all characters but line
ending characters. In RegExr, replace your current expression with:</p>
<pre><code>.</code></pre>
<p>An equivalent character class to dot would be combining any class and its
negated class:</p>
<pre><code>[\w\W]</code></pre>
<p>It can be tempting (and very lazy) to use dot as our character class as we can
often be more specific about the text phrases we are looking to match.</p>
</div>
<div id="using-quantifiers" class="section level3 hasAnchor" number="4.2.8">
<h3><span class="header-section-number">4.2.8</span> Using quantifiers<a href="string.html#using-quantifiers" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<table>
<caption><span id="tab:quant">Table 4.2: </span> Quantifiers used after a character class.</caption>
<thead>
<tr class="header">
<th>Quantifier</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>*</code></td>
<td>0 or more</td>
</tr>
<tr class="even">
<td><code>+</code></td>
<td>1 or more</td>
</tr>
<tr class="odd">
<td><code>?</code></td>
<td>0 or 1</td>
</tr>
<tr class="even">
<td><code>{3}</code></td>
<td>exactly 3</td>
</tr>
<tr class="odd">
<td><code>{3,}</code></td>
<td>3 or more</td>
</tr>
<tr class="even">
<td><code>{3,5}</code></td>
<td>3, 4, or 5</td>
</tr>
</tbody>
</table>
<p>So far we have been matching individual characters or literal text, hence why
when we use expressions such as <code>\w</code> all word
characters are individually highlighted. To highlight all words as a whole:</p>
<pre><code>\w+</code></pre>
<p>or</p>
<pre><code>[a-zA-Z0-9]+</code></pre>
<p>The plus symbol here is used to state how many times we match the character
class. <code>+</code> specifically means “1 or more” characters from
the preceding character class.</p>
<p>Other quantifiers are shown in Table <a href="string.html#tab:quant">4.2</a>. For example to
highlight all three-letter sequences use the expression:</p>
<pre><code>\w{3}</code></pre>
<p>See the result? If we want to select words that are 3 letters long, we can wrap this in a word boundary <code>\b</code>:</p>
<pre><code>\b\w{3}\b</code></pre>
<p>How would you modify this to match four-letter words? Six- to seven-letter
words? Also look at the differences in results between the two expressions:</p>
<pre><code>\w{3}</code></pre>
<p>and</p>
<pre><code>.{3}</code></pre>
</div>
<div id="matching-alternate-patterns" class="section level3 hasAnchor" number="4.2.9">
<h3><span class="header-section-number">4.2.9</span> Matching alternate patterns<a href="string.html#matching-alternate-patterns" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We can write regular expressions that state that there is a choice of
patterns to match.
For example, say you wanted to find how many occurrences of the word,
“the”, there are in the text you have selected for analysis.
The problem is, the word can occur as <em>THE</em>, <em>The</em>, and
<em>the</em>. You can use alternation to deal with this by writing
the following expression:</p>
<pre><code>\b(the|The|THE)\b</code></pre>
<p>and you will see all occurrences of <em>the</em> in the text highlighted.</p>
<p>Being able to specify alternate patterns like this allows us to create
sub-patterns in our expressions. Consider what words the following expression
will match and why:</p>
<pre><code>[tT]{1}h(eir|ere)</code></pre>
</div>
<div id="going-deeper" class="section level3 hasAnchor" number="4.2.10">
<h3><span class="header-section-number">4.2.10</span> Going deeper<a href="string.html#going-deeper" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If you are interested in learning more about regular expressions, seek out
at least one of the following books:</p>
<ul>
<li>Introducing Regular Expressions (2012) by M. Fitzgerald (O’Reilly Media).</li>
<li>Mastering Regular Expressions, Third Edition (2006) by J. Friedl (O’Reilly Media).</li>
<li>Regular Expressions Cookbook, Second Edition (2012) by J. Goyvaerts and S. Levithan (O’Reilly Media).</li>
</ul>
<p>These cover a lot more than these notes. Each can serve as a good reference
book.</p>
</div>
</div>
<div id="working-with-strings-and-regular-expressions" class="section level2 hasAnchor" number="4.3">
<h2><span class="header-section-number">4.3</span> Working with strings and regular expressions<a href="string.html#working-with-strings-and-regular-expressions" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Base R provides a solid set of string manipulation functions, but because
they have grown organically over time, they can be inconsistent and difficult
to learn. Additionally, some string processing tasks that are
easy to do in languages like Ruby or Python are rather hard to do in R.
The aim of the <code>stringr</code> package is overcome these problems
by providing a clean, modern interface to common string operations.
Some but not all allow the use of regular expressions.</p>
<div id="basic-string-operations" class="section level3 hasAnchor" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> Basic string operations<a href="string.html#basic-string-operations" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The following functions allow us to manipulate strings on a manual level
rather than using any pattern matching:</p>
<ul>
<li><code>str_c()</code> is equivalent to <code>paste()</code> which you may have already used, it concatenates vectors but it uses the empty string (<code>""</code>) as the default separator rather than a single whitespace (<code>" "</code>) and silently removes zero length arguments.</li>
</ul>
<p>Consider each of the following <code>str_c()</code> statements and how each differs from the previous:</p>
<div class="sourceCode" id="cb525"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb525-1"><a href="string.html#cb525-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb525-2"><a href="string.html#cb525-2" tabindex="-1"></a>  <span class="at">animal =</span> <span class="fu">c</span>(<span class="st">&quot;human&quot;</span>, <span class="st">&quot;blue whale&quot;</span>, <span class="st">&quot;cat&quot;</span>, <span class="st">&quot;dog&quot;</span>),</span>
<span id="cb525-3"><a href="string.html#cb525-3" tabindex="-1"></a>  <span class="at">food   =</span> <span class="fu">c</span>(<span class="st">&quot;pizza&quot;</span>, <span class="st">&quot;plankton&quot;</span>, <span class="st">&quot;human&quot;</span>, <span class="st">&quot;anything&quot;</span>),</span>
<span id="cb525-4"><a href="string.html#cb525-4" tabindex="-1"></a>  <span class="at">when   =</span> <span class="fu">c</span>(<span class="st">&quot;this week&quot;</span>, <span class="st">&quot;now and then&quot;</span>, <span class="st">&quot;now&quot;</span>, <span class="st">&quot;always&quot;</span>)</span>
<span id="cb525-5"><a href="string.html#cb525-5" tabindex="-1"></a>)</span>
<span id="cb525-6"><a href="string.html#cb525-6" tabindex="-1"></a></span>
<span id="cb525-7"><a href="string.html#cb525-7" tabindex="-1"></a><span class="fu">str_c</span>(dat<span class="sc">$</span>animal, <span class="st">&quot; wants to eat &quot;</span>, dat<span class="sc">$</span>food)</span></code></pre></div>
<pre><code>## [1] &quot;human wants to eat pizza&quot;         &quot;blue whale wants to eat plankton&quot;
## [3] &quot;cat wants to eat human&quot;           &quot;dog wants to eat anything&quot;</code></pre>
<div class="sourceCode" id="cb527"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb527-1"><a href="string.html#cb527-1" tabindex="-1"></a><span class="fu">str_c</span>(dat<span class="sc">$</span>animal, dat<span class="sc">$</span>food, <span class="at">sep =</span> <span class="st">&quot; wants to eat &quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;human wants to eat pizza&quot;         &quot;blue whale wants to eat plankton&quot;
## [3] &quot;cat wants to eat human&quot;           &quot;dog wants to eat anything&quot;</code></pre>
<div class="sourceCode" id="cb529"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb529-1"><a href="string.html#cb529-1" tabindex="-1"></a><span class="fu">str_c</span>(dat<span class="sc">$</span>animal, dat<span class="sc">$</span>food, dat<span class="sc">$</span>when, <span class="at">sep =</span> <span class="st">&quot; wants to eat &quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;human wants to eat pizza wants to eat this week&quot;           
## [2] &quot;blue whale wants to eat plankton wants to eat now and then&quot;
## [3] &quot;cat wants to eat human wants to eat now&quot;                   
## [4] &quot;dog wants to eat anything wants to eat always&quot;</code></pre>
<div class="sourceCode" id="cb531"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb531-1"><a href="string.html#cb531-1" tabindex="-1"></a><span class="fu">str_c</span>(dat<span class="sc">$</span>animal, <span class="st">&quot; wants to eat &quot;</span>, dat<span class="sc">$</span>food, <span class="st">&quot; &quot;</span>, dat<span class="sc">$</span>when)</span></code></pre></div>
<pre><code>## [1] &quot;human wants to eat pizza this week&quot;           
## [2] &quot;blue whale wants to eat plankton now and then&quot;
## [3] &quot;cat wants to eat human now&quot;                   
## [4] &quot;dog wants to eat anything always&quot;</code></pre>
<p>How strings are concatenated and collapsed can be modified by additional
arguments to <code>str_c()</code>, check the help page to see how.
<!-- In general, `str_c()` behaves in a more useful and consistent -->
<!-- manner than `paste()`. --></p>
<ul>
<li><code>str_length()</code> calculates the length of a string (as the number of characters in the string). If passed a vector it will return a vector of lengths.</li>
</ul>
<div class="sourceCode" id="cb533"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb533-1"><a href="string.html#cb533-1" tabindex="-1"></a><span class="fu">str_length</span>(dat<span class="sc">$</span>animal)</span></code></pre></div>
<pre><code>## [1]  5 10  3  3</code></pre>
</div>
<div id="consumer-packaged-breakfast-goods" class="section level3 hasAnchor" number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> Consumer Packaged Breakfast Goods<a href="string.html#consumer-packaged-breakfast-goods" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The following sections look at how we perform various string processing tasks
within R using regular expressions. To give context to when these types of tasks
are useful we will be working on a data set which contains nutritional
information and ingredient lists for 6,600 breakfast products. Download
<code>cpg_breakfast.csv</code> from Moodle and open it in Excel to
understand the structure, then read it into R (prevent
auto-conversion of strings to factors).</p>
<div class="sourceCode" id="cb535"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb535-1"><a href="string.html#cb535-1" tabindex="-1"></a>bf <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">&quot;cpg_breakfast.csv&quot;</span>, <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>A variable description is presented in Table <a href="string.html#tab:bfast-vars">4.3</a>.
Only convert <code>manufacturer</code> and <code>brand</code> to factors.</p>
<div class="sourceCode" id="cb536"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb536-1"><a href="string.html#cb536-1" tabindex="-1"></a>bf <span class="ot">&lt;-</span> bf <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(<span class="at">manufacturer =</span> <span class="fu">as.factor</span>(manufacturer),</span>
<span id="cb536-2"><a href="string.html#cb536-2" tabindex="-1"></a>                    <span class="at">brand =</span> <span class="fu">as.factor</span>(brand))</span></code></pre></div>
<p>We will now be mainly working with the ingredient lists.</p>
<table>
<caption><span id="tab:bfast-vars">Table 4.3: </span> Description of relevant variables in the breakfast dataset.</caption>
<thead>
<tr class="header">
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>manufacturer</code></td>
<td>The manufacturer or parent company of the product</td>
</tr>
<tr class="even">
<td><code>brand</code></td>
<td>The brand name commonly used by consumers</td>
</tr>
<tr class="odd">
<td><code>product_name</code></td>
<td>The name of the product. May include variant information such as colour or flavour</td>
</tr>
<tr class="even">
<td><code>ingredients</code></td>
<td>List of ingredients as they appear on the products packaging (comma separated).</td>
</tr>
<tr class="odd">
<td><code>calories</code></td>
<td>Total calories per serving.</td>
</tr>
<tr class="even">
<td><code>total_carb</code></td>
<td>Total amount of carbohydrates (grams).</td>
</tr>
<tr class="odd">
<td><code>total_fat</code></td>
<td>Total amount of fat (grams).</td>
</tr>
<tr class="even">
<td><code>size</code></td>
<td>Size information as shown on the packaging.</td>
</tr>
<tr class="odd">
<td><code>avg_price</code></td>
<td>Average price in dollars.</td>
</tr>
<tr class="even">
<td><code>ean13</code></td>
<td>The EAN-13 barcode used for identifying products worldwide.</td>
</tr>
</tbody>
</table>
</div>
<div id="detect-if-a-match-can-be-found-within-a-string" class="section level3 hasAnchor" number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> Detect if a match can be found within a string<a href="string.html#detect-if-a-match-can-be-found-within-a-string" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The first brick wall we run in to when using regular expressions in R is that
instead of simply using one backslash for character classes
(e.g. <code>\w</code>) we have to use two (e.g. <code>\\w</code>).</p>
<p>Let us try to determine how many breakfast products in our data contain
oats. First we create the expression:</p>
<div class="sourceCode" id="cb537"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb537-1"><a href="string.html#cb537-1" tabindex="-1"></a>expr <span class="ot">&lt;-</span> <span class="st">&quot;</span><span class="sc">\\</span><span class="st">b[oO]ats</span><span class="sc">\\</span><span class="st">b&quot;</span></span></code></pre></div>
<p>which looks similar to the expressions we were creating earlier; we are looking
to match either “oats” or “Oats” as whole words only. To then detect if either
of these appear in the ingredients we do:</p>
<div class="sourceCode" id="cb538"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb538-1"><a href="string.html#cb538-1" tabindex="-1"></a>bf<span class="sc">$</span>has_oats <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(bf<span class="sc">$</span>ingredients, expr)</span></code></pre></div>
<p>This has added the variable <code>has_oats</code> to our data frame, and it will contain a series of <code>TRUE</code> and <code>FALSE</code> values depending on whether or not our expression was matched in the <code>ingredients</code> strings. To summarise:</p>
<div class="sourceCode" id="cb539"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb539-1"><a href="string.html#cb539-1" tabindex="-1"></a><span class="fu">table</span>(bf<span class="sc">$</span>has_oats)</span></code></pre></div>
<pre><code>## 
## FALSE  TRUE 
##  2708  1644</code></pre>
<p>In terms of creating features from text-variables <code>str_detect()</code> is
probably the most useful. Practice by looking for other common breakfast
ingredients such as: corn and rice. <strong>Exercise</strong>: Create a expression that will detect
any instance of sugar, honey, or syrup.</p>
</div>
<div id="extract-the-matched-text" class="section level3 hasAnchor" number="4.3.4">
<h3><span class="header-section-number">4.3.4</span> Extract the matched text<a href="string.html#extract-the-matched-text" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>There are many different types of syrup (e.g. agave, maple, corn). Write
an expression that retrieves “syrup” and the preceding word:</p>
<div class="sourceCode" id="cb541"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb541-1"><a href="string.html#cb541-1" tabindex="-1"></a>expr <span class="ot">&lt;-</span> <span class="st">&quot;</span><span class="sc">\\</span><span class="st">w+ [sS]yrup&quot;</span></span>
<span id="cb541-2"><a href="string.html#cb541-2" tabindex="-1"></a>bf<span class="sc">$</span>syrup_type <span class="ot">&lt;-</span> <span class="fu">str_extract</span>(bf<span class="sc">$</span>ingredients, expr)</span>
<span id="cb541-3"><a href="string.html#cb541-3" tabindex="-1"></a><span class="fu">table</span>(bf<span class="sc">$</span>syrup_type)</span></code></pre></div>
<pre><code>## 
##         Agave Syrup        Barley Syrup          Cane Syrup       Caramel Syrup 
##                  11                   7                  61                   1 
##       Chicory Syrup          Corn Syrup          Date Syrup        Ginger Syrup 
##                   1                 807                   7                   1 
##       Glucose Syrup        Invert Syrup         Juice Syrup          Malt Syrup 
##                  27                   2                  36                 103 
##      Maltitol Syrup         Maple Syrup           Oat Syrup Oligofructose Syrup 
##                   7                 121                  28                   2 
##     Pineapple Syrup      Refiners Syrup      Refinery Syrup          Rice Syrup 
##                  14                   1                   1                 280 
##          Root Syrup         Sugar Syrup       Tapioca Syrup         Wheat Syrup 
##                   4                 111                  47                   1 
##             s Syrup 
##                   3</code></pre>
<p>We can see that corn syrup is a fairly common ingredient. How many of these
matches are actually for “high fructose corn syrup”? In general, we can extend
our expression to try to capture all proceeding words (remember the ingredients
are comma separated):</p>
<div class="sourceCode" id="cb543"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb543-1"><a href="string.html#cb543-1" tabindex="-1"></a>expr <span class="ot">&lt;-</span> <span class="st">&quot;,[ a-zA-Z]*[sS]yrup,&quot;</span></span>
<span id="cb543-2"><a href="string.html#cb543-2" tabindex="-1"></a>bf<span class="sc">$</span>syrup_type <span class="ot">&lt;-</span> <span class="fu">str_extract</span>(bf<span class="sc">$</span>ingredients, expr)</span>
<span id="cb543-3"><a href="string.html#cb543-3" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">table</span>(bf<span class="sc">$</span>syrup_type))</span></code></pre></div>
<pre><code>## 
##       , Agave Syrup, , Barley Malt Syrup,      , Barley Syrup, 
##                    3                   38                    1 
##  , Brown Rice Syrup, , Brown Sugar Syrup,  , Cane Juice Syrup, 
##                  163                  108                    1</code></pre>
<p>But now our <code>syrup_type</code> variable contains commas and whitespace. We
can tidy this up by writing an expression that keeps all characters between
the first and the last comma. To do this we use parentheses
around the part of the expression that we want to keep:</p>
<div class="sourceCode" id="cb545"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb545-1"><a href="string.html#cb545-1" tabindex="-1"></a>expr <span class="ot">&lt;-</span> <span class="st">&quot;, (.*),&quot;</span></span></code></pre></div>
<p>Because the text we are now working on (the text in <code>bf$syrup_type</code>) is
small we can risk being a bit lazy with our expression hence why I use dot-star.
When we use parentheses like this it is known as grouping, with the first
set of parentheses being referenced as group one. To only keep the text that
matches inside the brackets:</p>
<div class="sourceCode" id="cb546"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb546-1"><a href="string.html#cb546-1" tabindex="-1"></a>expr2 <span class="ot">&lt;-</span> <span class="st">&quot;</span><span class="sc">\\</span><span class="st">1&quot;</span></span>
<span id="cb546-2"><a href="string.html#cb546-2" tabindex="-1"></a>bf<span class="sc">$</span>syrup_type <span class="ot">&lt;-</span> <span class="fu">str_replace</span>(bf<span class="sc">$</span>syrup_type, expr, expr2)</span>
<span id="cb546-3"><a href="string.html#cb546-3" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">table</span>(bf<span class="sc">$</span>syrup_type))</span></code></pre></div>
<pre><code>## 
##       Agave Syrup Barley Malt Syrup      Barley Syrup  Brown Rice Syrup 
##                 3                38                 1               163 
## Brown Sugar Syrup  Cane Juice Syrup 
##               108                 1</code></pre>
<p>It is possible to have multiple sets of parentheses in our expression, these
would then be accessed using <code>"\\2"</code>, <code>"\\3"</code>, etc. Also, here our second
expression is very simple, we are free to make this more complicated by
including literal text:</p>
<div class="sourceCode" id="cb548"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb548-1"><a href="string.html#cb548-1" tabindex="-1"></a>expr  <span class="ot">&lt;-</span> <span class="st">&quot;(.*)&quot;</span></span>
<span id="cb548-2"><a href="string.html#cb548-2" tabindex="-1"></a>expr2 <span class="ot">&lt;-</span> <span class="st">&quot;I have found </span><span class="sc">\\</span><span class="st">1!&quot;</span></span>
<span id="cb548-3"><a href="string.html#cb548-3" tabindex="-1"></a>bf<span class="sc">$</span>syrup_type <span class="ot">&lt;-</span> <span class="fu">str_replace</span>(bf<span class="sc">$</span>syrup_type, expr, expr2)</span>
<span id="cb548-4"><a href="string.html#cb548-4" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">table</span>(bf<span class="sc">$</span>syrup_type))</span></code></pre></div>
<pre><code>## 
##       I have found Agave Syrup! I have found Barley Malt Syrup! 
##                               3                              38 
##      I have found Barley Syrup!  I have found Brown Rice Syrup! 
##                               1                             163 
## I have found Brown Sugar Syrup!  I have found Cane Juice Syrup! 
##                             108                               1</code></pre>
<p><code>expr2</code> works in a similar way to the concatenating we did earlier with <code>str_c()</code>.
<strong>Exercise</strong>: Try this process of extracting again, but now look for instances of vitamins being
added to the product. Commonly added vitamins are A, B12, C, D, and E, ensure
your expression can capture these.</p>
<p><code>str_extract()</code> will only retrieve the first match from a string. To
retrieve all vitamins that are added to a product use
<code>str_extract_all()</code>. Though you will not be able to store the results of
that are returned from <code>str_extract_all()</code> simply in a variable in
your data frame. Store the results in an object separate from your data frame
and inspect it.</p>
</div>
<div id="replace-matches" class="section level3 hasAnchor" number="4.3.5">
<h3><span class="header-section-number">4.3.5</span> Replace matches<a href="string.html#replace-matches" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Say, we know someone who is a vegan, this someone also happens to be
fairly good with regular expressions, let’s call this person Rose Myris. If Rose Myris
wanted to replace all instances of meat-based ingredients with the phrase
“dead animal” then she could do this by using <code>str_replace()</code>.
Firstly, let’s find some breakfast foods that do actually contain meat:</p>
<div class="sourceCode" id="cb550"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb550-1"><a href="string.html#cb550-1" tabindex="-1"></a>expr <span class="ot">&lt;-</span> <span class="st">&quot;(Duck|Beef|Pork|Bacon|Chicken|Poultry|Turkey)&quot;</span></span>
<span id="cb550-2"><a href="string.html#cb550-2" tabindex="-1"></a>bf <span class="ot">&lt;-</span> bf <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(<span class="at">has_meat =</span> <span class="fu">str_detect</span>(ingredients, expr))</span>
<span id="cb550-3"><a href="string.html#cb550-3" tabindex="-1"></a>bf_meat <span class="ot">&lt;-</span> <span class="fu">filter</span>(bf, has_meat <span class="sc">==</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>Inspect <code>bf_meat</code> to see the kinds of products we are dealing with,
in particular look at row 169 (which also includes corn syrup).
Using <code>str_replace()</code>, we can reuse the same expression in order
to swap out each type of meat for a different phrase:</p>
<div class="sourceCode" id="cb551"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb551-1"><a href="string.html#cb551-1" tabindex="-1"></a>bf_meat <span class="ot">&lt;-</span> bf_meat <span class="sc">%&gt;%</span></span>
<span id="cb551-2"><a href="string.html#cb551-2" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">ingredients =</span> <span class="fu">str_replace</span>(ingredients, expr, <span class="st">&quot;Dead animal&quot;</span>)) </span></code></pre></div>
<p>Now look at what changes have been made to the ingredients in <code>bf_meat</code>.
In each string only the first match has been replaced. Obviously, Rose Myris,
would prefer to have all matches replaced, the is where
<code>str_replace_all()</code> comes in to action:</p>
<div class="sourceCode" id="cb552"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb552-1"><a href="string.html#cb552-1" tabindex="-1"></a>bf_meat <span class="ot">&lt;-</span> bf_meat <span class="sc">%&gt;%</span></span>
<span id="cb552-2"><a href="string.html#cb552-2" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">ingredients =</span> <span class="fu">str_replace_all</span>(ingredients, expr, <span class="st">&quot;Dead animal&quot;</span>)) </span></code></pre></div>
<p>At last, Rose Myris’ anger can now reach new heights! To really get her blood
boiling let’s count how many replaces were made:</p>
<div class="sourceCode" id="cb553"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb553-1"><a href="string.html#cb553-1" tabindex="-1"></a>dead_hits <span class="ot">&lt;-</span> <span class="fu">str_match_all</span>(bf_meat<span class="sc">$</span>ingredients, <span class="st">&quot;Dead animal&quot;</span>)</span>
<span id="cb553-2"><a href="string.html#cb553-2" tabindex="-1"></a></span>
<span id="cb553-3"><a href="string.html#cb553-3" tabindex="-1"></a>dead_count <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb553-4"><a href="string.html#cb553-4" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(dead_hits)) {</span>
<span id="cb553-5"><a href="string.html#cb553-5" tabindex="-1"></a>    dead_count[i] <span class="ot">&lt;-</span> <span class="fu">length</span>(dead_hits[[i]])</span>
<span id="cb553-6"><a href="string.html#cb553-6" tabindex="-1"></a>}</span>
<span id="cb553-7"><a href="string.html#cb553-7" tabindex="-1"></a><span class="fu">sum</span>(dead_count)</span></code></pre></div>
<pre><code>## [1] 315</code></pre>
<p>An alternative way to code this which avoids the loop is:</p>
<div class="sourceCode" id="cb555"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb555-1"><a href="string.html#cb555-1" tabindex="-1"></a>dead_count <span class="ot">&lt;-</span> <span class="fu">lengths</span>(dead_hits)</span>
<span id="cb555-2"><a href="string.html#cb555-2" tabindex="-1"></a><span class="fu">sum</span>(dead_count)</span></code></pre></div>
<pre><code>## [1] 315</code></pre>
<p>We can then look at the worst offender.</p>
<div class="sourceCode" id="cb557"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb557-1"><a href="string.html#cb557-1" tabindex="-1"></a>bf_meat[<span class="fu">which.max</span>(dead_count), ]</span></code></pre></div>
<pre><code>##    manufacturer  brand product_name size
## 12              Turkey Turkey Bacon 6 oz
##                                                                                                                                                                                                                                                                                   ingredients
## 12 Dead animal, Mechanically Separated Dead animal, Dead animal, Dead animal Flavor, Rendered Dead animal Fat, Smokey Flavoring, Cooked Dead animal, Cured With Water, Salt, Sugar, Smoke Flavorings, Sodium Phosphate, Sodium Erythorbate, Sodium Nitrite, Flavoring, Water, Autolyzed Yeast
##    avg_price       ean13 serving_size calories fat_calories total_fat sat_fat
## 12      2.29 45300303659     3 slices       70           50         5       2
##    trans_fat cholesterol sodium potassium total_carb dietary_fiber sugars
## 12         0          20    360         0          1             0      1
##    protein polyunsat_fat monounsat_fat soluble_fiber insoluble_fiber calcium
## 12       4             0             0             0               0       2
##    iron has_oats syrup_type has_meat
## 12    2    FALSE       &lt;NA&gt;     TRUE</code></pre>
</div>
<div id="building-large-expressions" class="section level3 hasAnchor" number="4.3.6">
<h3><span class="header-section-number">4.3.6</span> Building large expressions<a href="string.html#building-large-expressions" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If we wanted to find products that contained fruit, we simply have to create
one long alternating pattern of literal fruit names (e.g. <code>(apple|orange|pear|raisin)</code>, as there is no smart compact expression we can write down that will match only fruit names.</p>
<p>There should be a data set <code>fruit</code> in the package <code>stringr</code> that is just a vector of fruit names. Load it in R and have a look:</p>
<div class="sourceCode" id="cb559"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb559-1"><a href="string.html#cb559-1" tabindex="-1"></a><span class="fu">data</span>(fruit)</span>
<span id="cb559-2"><a href="string.html#cb559-2" tabindex="-1"></a><span class="fu">head</span>(fruit)</span></code></pre></div>
<pre><code>## [1] &quot;apple&quot;       &quot;apricot&quot;     &quot;avocado&quot;     &quot;banana&quot;      &quot;bell pepper&quot;
## [6] &quot;bilberry&quot;</code></pre>
<p>Check the length of <code>fruit</code> to see how many we actually have. We also make the first letter of the name upper case:</p>
<div class="sourceCode" id="cb561"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb561-1"><a href="string.html#cb561-1" tabindex="-1"></a>fruit <span class="ot">&lt;-</span> <span class="fu">str_to_sentence</span>(fruit)</span>
<span id="cb561-2"><a href="string.html#cb561-2" tabindex="-1"></a><span class="fu">head</span>(fruit)</span></code></pre></div>
<pre><code>## [1] &quot;Apple&quot;       &quot;Apricot&quot;     &quot;Avocado&quot;     &quot;Banana&quot;      &quot;Bell pepper&quot;
## [6] &quot;Bilberry&quot;</code></pre>
<p>Next, we can start to build our expression by first collapsing all the different fruit names together, and then adding parenthesis either side:</p>
<div class="sourceCode" id="cb563"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb563-1"><a href="string.html#cb563-1" tabindex="-1"></a>fruit_expr <span class="ot">&lt;-</span> <span class="fu">str_c</span>(fruit, <span class="at">collapse =</span> <span class="st">&quot;|&quot;</span>)</span>
<span id="cb563-2"><a href="string.html#cb563-2" tabindex="-1"></a>fruit_expr <span class="ot">&lt;-</span> <span class="fu">str_c</span>(<span class="st">&quot;(&quot;</span>, fruit_expr, <span class="st">&quot;)&quot;</span>)</span>
<span id="cb563-3"><a href="string.html#cb563-3" tabindex="-1"></a><span class="fu">str_length</span>(fruit_expr)</span></code></pre></div>
<pre><code>## [1] 728</code></pre>
<p>Our fruit expression has 728 characters which means it’s very long. Let’s put this into action:</p>
<div class="sourceCode" id="cb565"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb565-1"><a href="string.html#cb565-1" tabindex="-1"></a>bf<span class="sc">$</span>has_fruit <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(bf<span class="sc">$</span>ingredients, fruit_expr)</span>
<span id="cb565-2"><a href="string.html#cb565-2" tabindex="-1"></a><span class="fu">table</span>(bf<span class="sc">$</span>has_fruit)</span></code></pre></div>
<pre><code>## 
## FALSE  TRUE 
##  2662  1690</code></pre>
<p>We can use this technique of concatenating a list to build several features,
such as whether or not a product:</p>
<ul>
<li>Contains gluten.</li>
<li>Is suitable for those who are lactose-intolerant.</li>
<li>Is suitable for vegetarians or vegans.</li>
</ul>
<p>For each of these we would need to create specific lists which we
would then collapse to form a single, but very long, expression. In some cases,
it may be easier to try to match ingredients that they can not or will not eat
rather than match those that they can.</p>
</div>
</div>
<div id="string-exercises" class="section level2 hasAnchor" number="4.4">
<h2><span class="header-section-number">4.4</span> String Exercises<a href="string.html#string-exercises" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<ol style="list-style-type: decimal">
<li>Create separate boxplots comparing the distribution of total
carbohydrates in fruit-based and non-fruit-based breakfast food.</li>
<li>Repeat but for total fat instead of total carbs.</li>
<li>The are a wide variety of products that class as breakfast food:</li>
</ol>
<ul>
<li>Cereal-bars</li>
<li>Cereal (e.g. corn flakes, porridge, granola, puffed rice)</li>
<li>Waffles, pancakes</li>
<li>Delicious baked goods (e.g. croissants, pan au chocolat)</li>
<li>Meat products (e.g. sausage, bacon)</li>
<li>Other</li>
</ul>
<p>Construct regular expressions which attempt to classify products into these
groups. You will have to decide which variable in the data set is the most
appropriate to be working with. You may need to break this task down into
several smaller sub-tasks.</p>
<p>Once complete, construct similar boxplots to the first two tasks, comparing
distributions of total fat and carbs for these groups.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="loops-sim.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="web-app.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
